{% comment %}
MCC Product Content Sections – left column (now accordion-wrapped)
Order: Description → Flavor → Growing → Brew → Reviews → Recommendations
{% endcomment %}

<div class="product-sections"><!-- keeps padding: 0 32px -->

  <!-- DESCRIPTION -->
  {% assign merch_desc = product.metafields.merch.description_html | default: blank %}
  {% assign desc_html  = merch_desc | default: product.description %}
  {% if desc_html != blank %}
    <section class="mcc-merch-description description-section">
      <h2 class="coffee-acc-title desc-title">Description</h2>
      <div class="description-content rte">
        {{ desc_html }}
      </div>
    </section>
  {% endif %}

  <!-- DETAILS -->
  {% assign merch_details = product.metafields.custom.merch_details %}
  {% if merch_details != blank %}
    <section class="mcc-merch-details details-section description-section">
      <h2 class="coffee-acc-title desc-title">Details</h2>
      <div class="details-content description-content rte">
        {{ merch_details | metafield_tag }}
      </div>
    </section>
  {% endif %}

  <!-- Reviews (Judge.me) – full review widget (server-rendered) -->
 <!-- REVIEWS (Judge.me) -->
 
<section class="coffee-accordion content-section" data-accordion data-acc="reviews" data-stagger="rows">
  <header class="coffee-acc-header">
    <h2 class="coffee-acc-title coffee-reviews-title">Recent reviews</h2>
    <button class="coffee-acc-trigger" type="button"
            aria-controls="acc-reviews-{{ section.id }}" aria-expanded="true">
      <span class="sr-only">Toggle Recent reviews</span>
    </button>
  </header>

  <!-- ✅ PANEL that the button controls -->
  <div id="acc-reviews-{{ section.id }}" class="coffee-acc-panel" data-acc-panel>
    <!-- Your reviews module lives inside the panel -->
    <div class="pdp-module pdp-reviews" id="reviews" data-mcc-reviews>
  {%- comment -%}
      <div id="judgeme_product_reviews"
           class="jdgm-widget jdgm-review-widget"
           data-product-title="{{ product.title | escape }}"
           data-id="{{ product.id }}">
        {{ product.metafields.judgeme.widget }}
      </div>
  {%- endcomment -%}
      <div class="mcc-reviews-controls">
        <button type="button" class="mcc-load-prev">Previous</button>
        <button type="button" class="mcc-load-next">Next</button>
      </div>
    </div>
  </div>

<script>
  // Desktop pager ON, mobile pager OFF (one-shot; no resize listeners)
  window.__MCC_DISABLE_REVIEWS_PAGER__ =
    !window.matchMedia('(min-width: 768px)').matches ? true : false;
</script>

  

  <!-- DROP-IN SCRIPT -->
<script>
(function(){
  const mq = window.matchMedia('(max-width: 767.98px)');
  function apply(){ window.__MCC_DISABLE_REVIEWS_PAGER__ = mq.matches; }
  apply();
  (mq.addEventListener ? mq.addEventListener('change', apply) : mq.addListener(apply));
})();
</script>


<script>
(function mccReviewsPager_v3_4_2(){
  if (window.__MCC_DISABLE_REVIEWS_PAGER__) return;

  const HOST_SEL = '#reviews.pdp-reviews';           // <— tightened
  const LIST_SEL = '.jdgm-rev-widg__reviews';
  const CARD_SEL = '.jdgm-rev';
  const NEXT_SEL = '.jdgm-paginate__load-more, .jdgm-paginate [rel="next"], .jdgm-paginate a, .jdgm-paginate button';

  const PAGE_SIZE = 6, PEEK_PX = 56;
  const host = document.querySelector(HOST_SEL);
  if (!host) return;

  const list     = () => host.querySelector(LIST_SEL);
  const cards    = () => list() ? Array.from(list().querySelectorAll(CARD_SEL)) : [];
  const jdgmNext = () => host.querySelector(NEXT_SEL);

  function btns(){ return {
    prev: host.querySelector('.mcc-load-prev'),
    next: host.querySelector('.mcc-load-next'),
  };}

  let loading = false;

  function viewport(){
    const l = list(); if (!l) return null;
    let vp = host.querySelector('.mcc-reviews-viewport');
    if (!vp){
      vp = document.createElement('div');
      vp.className = 'mcc-reviews-viewport';
      l.parentNode.insertBefore(vp, l);
      vp.appendChild(l);
    }
    return vp;
  }
  function peekRail(){
    const vp = viewport(); if (!vp) return null;
    let rail = vp.querySelector('.mcc-peek-rail');
    if (!rail){
      rail = document.createElement('div');
      rail.className = 'mcc-peek-rail';
      vp.appendChild(rail);
    }
    return rail;
  }
  function setFade(on){
    const vp = viewport(); if (!vp) return;
    vp.style.setProperty('--mcc-peek', on ? (PEEK_PX + 'px') : '0px');
    vp.style.setProperty('--peek',     on ? (PEEK_PX + 'px') : '0px');
  }
  function waitStable(idle=180, max=1400){
    const start = Date.now(); let last=-1, t;
    return new Promise(res=>{
      (function tick(){
        const c = cards().length;
        if (c!==last){ last=c; clearTimeout(t); t=setTimeout(done,idle); }
        if (Date.now()-start>max) return done();
        requestAnimationFrame(tick);
      })();
      function done(){ clearTimeout(t); res(); }
    });
  }
  function tagPages(){
    cards().forEach((c,i)=>{
      c.dataset.mccPage = Math.floor(i / PAGE_SIZE);
      c.classList.remove('is-hidden','is-peek');
    });
    host.dataset.mccLast = String(Math.max(0, Math.floor((cards().length-1)/PAGE_SIZE)));
  }
  function buildPeekFrom(idx){
    const rail = peekRail(); if (!rail) return false;
    rail.innerHTML = '';
    const nextCards = cards().filter(c => +c.dataset.mccPage === idx);
    if (!nextCards.length) return false;
    nextCards.forEach(orig=>{
      const clone = orig.cloneNode(true);
      clone.classList.remove('jdgm-rev');
      clone.classList.add('mcc-peek-card');
      clone.querySelectorAll('[id]').forEach(el => el.removeAttribute('id'));
      rail.appendChild(clone);
    });
    return true;
  }
  function nudgeMasonry(){
    const l = list(); if (!l) return;
    const cg = parseFloat(getComputedStyle(l).columnGap||12);
    l.style.columnGap = (cg+0.1)+'px'; void l.offsetHeight; l.style.columnGap = '';
  }
  function render(pageIdx, {animateDir}={}){
    const vp  = viewport(); if (!vp) return;
    const max = +host.dataset.mccLast || 0;
    const cur = Math.max(0, Math.min(pageIdx, max));
    host.dataset.mccCur = String(cur);

    const cs = cards();
    cs.forEach(c => c.classList.toggle('is-hidden', +c.dataset.mccPage !== cur));

    const hasNextLocal = (cur < max) && buildPeekFrom(cur+1);
    const hasRemote    = !!jdgmNext();
    setFade(hasNextLocal || hasRemote);

    if (animateDir){
      vp.classList.remove('is-swap'); void vp.offsetHeight; vp.classList.add('is-swap');
      setTimeout(()=> vp.classList.remove('is-swap'), 260);
    }
    nudgeMasonry();
    updateButtons();
  }
  function updateButtons(){
    const {prev, next} = btns();
    if (!prev || !next) return;
    const cur = +host.dataset.mccCur || 0;
    const max = +host.dataset.mccLast || 0;
    const remote = !!jdgmNext();

    prev.disabled = (cur <= 0);
    prev.setAttribute('aria-disabled', String(prev.disabled));

    next.disabled = !(cur < max || remote) || loading;
    next.setAttribute('aria-disabled', String(next.disabled));
  }
  function clickJDGMNext(cb){
    const nx = jdgmNext(); if (!nx) return;
    const l  = list(); if (!l) return;
    const mo = new MutationObserver(()=>{
      mo.disconnect();
      requestAnimationFrame(async ()=>{
        await waitStable();
        tagPages();
        cb && cb();
      });
    });
    mo.observe(l, { childList:true, subtree:true });
    nx.dispatchEvent(new MouseEvent('click',{bubbles:true,cancelable:true}));
  }

  async function boot(){
    await waitStable();
    let guard = 4;
    while (cards().length < PAGE_SIZE && jdgmNext() && guard--){
      await new Promise(r=> clickJDGMNext(r));
      await waitStable();
    }
    tagPages();
    render( Math.min(+host.dataset.mccCur||0, +host.dataset.mccLast||0) );
    wireClicks();    // ensure clicks are bound after DOM exists
    updateButtons();
  }

  function wireClicks(){
    const {prev, next} = btns();
    if (prev) prev.addEventListener('click', onPrev, {passive:false});
    if (next) next.addEventListener('click', onNext, {passive:false});

    // Delegation fallback in case buttons get re-rendered by theme
    host.addEventListener('click', (e)=>{
      if (e.target.closest('.mcc-load-prev')) { e.preventDefault(); onPrev(e); }
      if (e.target.closest('.mcc-load-next')) { e.preventDefault(); onNext(e); }
    });
  }

  function onPrev(e){
    e && e.preventDefault();
    const cur = +host.dataset.mccCur || 0;
    render(cur - 1, {animateDir:'prev'});
  }
  async function onNext(e){
    e && e.preventDefault();
    if (loading) return;
    const cur = +host.dataset.mccCur || 0;
    const max = +host.dataset.mccLast || 0;

    if (cur < max) return render(cur + 1, {animateDir:'next'});
    if (!jdgmNext()) return updateButtons();

    try{
      loading = true; updateButtons();
      await new Promise(r=> clickJDGMNext(r));
      await waitStable();
      tagPages();
      render(+host.dataset.mccLast || 0, {animateDir:'next'});
    } finally {
      loading = false; updateButtons();
    }
  }

  if (list() && cards().length) boot();
  else {
    const w = new MutationObserver(()=>{
      if (list() && cards().length){ w.disconnect(); boot(); }
    });
    w.observe(host, { childList:true, subtree:true });
  }
})();
</script>

</section>


{%- comment -%} Judge.me hydration logic (unchanged) {%- endcomment -%}
<!-- Reviews hydration -->

<script>
(function () {
  const LEFT = document.querySelector('[data-mcc-reviews]');
  if (!LEFT) return;

  function hydrate() {
    if (window.jdgm && typeof window.jdgm.initializeWidgets === 'function') {
      window.jdgm.initializeWidgets();
    }
  }

  function ensureReviewed(maxTries = 6) {
    let tries = 0;
    (function tick(){
      const reviewed = !!LEFT.querySelector('.jdgm-rev-widg');
      if (reviewed || ++tries > maxTries) return;
      hydrate();
      setTimeout(tick, 300);
    })();
  }

  LEFT.addEventListener('click', function (e) {
    const link = e.target && e.target.closest('.jdgm-write-rev-link');
    if (!link) return;
    e.preventDefault();
    e.stopImmediatePropagation();

    const form = LEFT.querySelector('.jdgm-rev-widg__form, .jdgm-form-wrapper, .jdgm-rev-widg__form-wrapper');
    if (form) {
      form.style.display = 'block';
      form.classList.remove('jdgm-hidden');
      form.removeAttribute('hidden');
      try { form.scrollIntoView({ behavior: 'smooth', block: 'start' }); } catch (_) {}
    }
  }, true);

  document.addEventListener('shopify:section:load', hydrate);
  hydrate();
  ensureReviewed();
})();
</script>


<script>
(() => {
  if (!matchMedia('(max-width: 767.98px)').matches) return;
  // desktop pager already gated by the one-liner above

  const host = document.querySelector('#reviews.pdp-reviews');
  if (!host) return;

  const LIST_SEL = '.jdgm-rev-widg__reviews';
  const CARD_SEL = '.jdgm-rev';
  const LONG_THRESHOLD = 220; // tweak if you want fewer/more wides

  const list = () => host.querySelector(LIST_SEL);


  // Watch for JDGM rendering & “Load more”
  const boot = new MutationObserver(() => {
    if (list()){
      sweep();
      // observe the list for appended reviews
      new MutationObserver(sweep).observe(list(), {childList:true, subtree:true});
      boot.disconnect();
    }
  });
  boot.observe(host, {childList:true, subtree:true});

  // one last pass in case it’s already there
  setTimeout(sweep, 300);
})();
</script>

<script>
(() => {
  if (!matchMedia('(max-width: 767.98px)').matches) return;

  const host = document.querySelector('#judgeme_product_reviews');
  if (!host) return;

  const LIST_SEL = '.jdgm-rev-widg__reviews';
  const CARD_SEL = '.jdgm-rev';
  const LONG_THRESHOLD = 200; // tweak up/down to change how many go wide

  const list = () => host.querySelector(LIST_SEL);

  function markWide(card){
    if (!card || card.classList.contains('mcc-wide')) return;
    const title = card.querySelector('.jdgm-rev__title')?.textContent || '';
    const body  = (card.querySelector('.jdgm-rev__body, .jdgm-rev__content')?.textContent || '');
    const len = (title + ' ' + body).trim().length;
    if (len >= LONG_THRESHOLD) card.classList.add('mcc-wide');
  }

  function sweep(){
    (list()?.querySelectorAll(CARD_SEL) || []).forEach(markWide);
  }

  // Run when JDGM renders and whenever it appends more reviews
  const mo = new MutationObserver(() => sweep());
  mo.observe(host, { childList: true, subtree: true });

  // One initial pass (in case content is already there)
  sweep();
})();
</script>

<script>
(() => {
  // Mobile only
  if (!matchMedia('(max-width: 767.98px)').matches) return;

  // Host & selectors
  const host = document.querySelector('#reviews.pdp-reviews');
  if (!host) return;
  const LIST_SEL = '.jdgm-rev-widg__reviews';
  const NEXT_SEL = '.jdgm-paginate__load-more, .jdgm-paginate [rel="next"], .jdgm-paginate a, .jdgm-paginate button';
  const CARD_SEL = '.jdgm-rev';
  const WIDE_THRESHOLD = 200; // tweak if you want more/fewer wides

  const list = () => host.querySelector(LIST_SEL);
  const jdgmNext = () => host.querySelector(NEXT_SEL);

  // --- wide-card helper (grid already in your CSS) ---
  function markWide(card){
    if (!card || card.classList.contains('mcc-wide')) return;
    const title = card.querySelector('.jdgm-rev__title')?.textContent || '';
    const body  = card.querySelector('.jdgm-rev__body, .jdgm-rev__content')?.textContent || '';
    if ((title + ' ' + body).trim().length >= WIDE_THRESHOLD) card.classList.add('mcc-wide');
  }
  function sweepWide(){
    (list()?.querySelectorAll(CARD_SEL) || []).forEach(markWide);
  }

  // --- tiny “wait until JDGM settles” helper ---
  function waitStable(idle=180, max=1400){
    const start = Date.now(); let last=-1, t;
    return new Promise(res=>{
      (function tick(){
        const cnt = list() ? list().children.length : 0;
        if (cnt !== last){ last = cnt; clearTimeout(t); t = setTimeout(done, idle); }
        if (Date.now()-start > max) return done();
        requestAnimationFrame(tick);
      })();
      function done(){ clearTimeout(t); res(); }
    });
  }

  // --- create / locate the one button ---
  function ensureButton(){
    let btn = host.querySelector('.mcc-mobile-more');
    if (!btn){
      btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'mcc-mobile-more';
      btn.textContent = 'See more reviews';
      // place after the JDGM widget if present, else at end of host
      const widg = host.querySelector('.jdgm-rev-widg');
      (widg || host).appendChild(btn);
    }
    return btn;
  }

  function updateButton(btn){
    const more = !!jdgmNext();
    btn.disabled = !more;
    btn.setAttribute('aria-disabled', String(!more));
    if (!more) btn.textContent = 'All reviews loaded';
  }

  async function clickMore(btn){
    const nx = jdgmNext();
    if (!nx) return updateButton(btn);
    btn.disabled = true;
    btn.textContent = 'Loading…';
    // Observe list, click JDGM’s hidden control, then wait for settle
    const l = list(); if (!l) return;
    const mo = new MutationObserver(()=>{ mo.disconnect(); });
    mo.observe(l, {childList:true, subtree:true});
    nx.dispatchEvent(new MouseEvent('click', {bubbles:true, cancelable:true}));
    await waitStable();
    sweepWide();                 // mark any new wides
    btn.textContent = 'See more reviews';
    updateButton(btn);
  }

  // --- boot when JDGM renders ---
  const boot = () => {
    if (!list()) return;
    const btn = ensureButton();
    sweepWide();
    updateButton(btn);
    btn.addEventListener('click', () => clickMore(btn));
  };

  if (list()) boot();
  else {
    const w = new MutationObserver(() => { if (list()){ w.disconnect(); boot(); }});
    w.observe(host, {childList:true, subtree:true});
  }

  // keep the button state fresh if JDGM appends more later
  new MutationObserver(() => {
    const btn = host.querySelector('.mcc-mobile-more');
    if (btn) updateButton(btn);
  }).observe(host, {childList:true, subtree:true});
})();
</script>


  <!-- RECOMMENDATIONS (standalone – no accordion, use snippet header) -->
<div class="content-section coffee-recs" id="recommendations" >
  {%- assign beans_col    = collections['beans'] -%}
  {%- assign merch_col    = collections['merch'] -%}
  {%- assign coldbrew_col = collections['cold-brew'] | default: collections['coldbrew'] -%}
  {%- assign product_col_handles = product.collections | map: 'handle' | join: ',' | downcase -%}

  {%- assign target_collection = nil -%}
  {%- if product_col_handles contains 'beans' and beans_col and beans_col.products_count > 1 -%}
    {%- assign target_collection = beans_col -%}
  {%- elsif product_col_handles contains 'merch' and merch_col and merch_col.products_count > 1 -%}
    {%- assign target_collection = merch_col -%}
  {%- elsif product_col_handles contains 'cold-brew' and coldbrew_col and coldbrew_col.products_count > 1 -%}
    {%- assign target_collection = coldbrew_col -%}
  {%- endif -%}

  {%- if target_collection == nil -%}
    {%- if beans_col and beans_col.products_count > 1 -%}
      {%- assign target_collection = beans_col -%}
    {%- elsif merch_col and merch_col.products_count > 1 -%}
      {%- assign target_collection = merch_col -%}
    {%- elsif coldbrew_col and coldbrew_col.products_count > 1 -%}
      {%- assign target_collection = coldbrew_col -%}
    {%- endif -%}
  {%- endif -%}

  {%- assign rec_products = '' -%}
  {%- if target_collection and target_collection.products -%}
    {%- assign rec_products = target_collection.products -%}
  {%- elsif collections['all'] and collections['all'].products_count > 1 -%}
    {%- assign rec_products = collections['all'].products -%}
  {%- endif -%}

  {%- if rec_products != blank -%}
    {% assign see_more = product.collections.first.url | default: '/collections/all' %}
    {% render 'mcc-recommended-products',
      product: product,
      products: rec_products,
      title: 'You might also like',
      limit: 6,
      see_more_url: see_more
    %}
  {%- endif -%}
</div>

</div>

